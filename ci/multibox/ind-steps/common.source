#!/bin/bash
. "${ENV_ROOTDIR}/external_libraries/bashsteps/simple-defaults-for-bashsteps.source"

function create_bridge() {
  local name="$1"
  local ip_addr="$2"

  (
    $starting_step "Create bridge ${name}"
    brctl show | grep -q "${name}"
    $skip_step_if_already_done ; set -xe
    sudo brctl addbr "${name}"
    sudo ip link set "${name}" up

    if [[ -n "${ip_addr}" ]]; then
      sudo ip addr add "${ip_addr}" dev "${name}"
    fi
  ) ; prev_cmd_failed
}

function check_dep() {
  local dep="$1"

  command -v "${dep}" >/dev/null 2>&1
  if [[ "$?" != "0" ]]; then
    echo "Missing dependency: ${dep}"
    exit 1
  fi
}

function download_seed_image () {
    local box="${1}"

    (
        $starting_step "Download ${box}"
        [ -f "${BOXES_DIR}/${box}" ]
        $skip_step_if_already_done
        mkdir -p "${BOXES_DIR}"
        wget "https://ci.openvdc.org/img/${box}" -P "${BOXES_DIR}/${box}"
    ) ; prev_cmd_failed
}

function masquerade() {
  local subnet="${1}"

  (
    $starting_step "Masquerade for subnet ${subnet}"
    sudo iptables-save | grep -wq "\-A POSTROUTING \-s ${subnet} \-j MASQUERADE"
    $skip_step_if_already_done
    sudo iptables -t nat -A POSTROUTING -s "${subnet}" -j MASQUERADE
  ) ; prev_cmd_failed
}

function stop_masquerade() {
  local subnet="${1}"

  (
    $starting_step "Stop masquerading for subnet ${subnet}"
    sudo iptables-save | grep -wq "\-A POSTROUTING \-s ${subnet} \-j MASQUERADE"
    [ "$?" != "0" ]
    $skip_step_if_already_done
    sudo iptables -t nat -D POSTROUTING -s "${subnet}" -j MASQUERADE
  ) ; prev_cmd_failed
}

function run_steps () {
    local step="${1}" stage="${2}"
    local step_common="${ENV_ROOTDIR}/ind-steps/step-${step}/common.source"
    (
        [[ -f "${step_common}" ]] && . "${step_common}"
        . "${ENV_ROOTDIR}/ind-steps/step-${step}/${stage}.sh"
    )
}

function build () {
    local steps="${@}"

    local stages=(
        $(
            $(sudo kill -0 $(sudo cat ${NODE_DIR}/${vm_name}.pid 2> /dev/null) 2> /dev/null) && { echo "postconfigure provide" ; return ; }
            $(sudo [ -f "${CACHE_DIR}/${BRANCH}/${vm_name}.qcow2" ]) && { echo "boot postconfigure provide" ; return ; }
            echo "init install preconfigure boot postconfigure provide"
        )
    )

    # We first run init.sh for every step after which we run install.sh for every
    # step and so on. This is because some stages will need to happen before booting
    # the VM while others need to happen after boot.
    for stage in ${stages[@]} ; do
        for step in ${steps[@]} ; do
            [[ -d "${ENV_ROOTDIR}/ind-steps/step-${step}" ]] || continue
            [[ -f "${ENV_ROOTDIR}/ind-steps/step-${step}/${stage}.sh" ]] && run_steps "${step}" "${stage}"
            [[ $? == 255 ]] && { . "${ENV_ROOTDIR}/ind-steps/step-box/common.source" ; umount-seed-image ; exit 255 ; }
        done 
    done

    unset -f ssh
}

function disable_service () {
    local service="${1}"

    (
        $starting_step "Disable service: ${service}"
        ssh root@${IP_ADDR} "systemctl status ${service} | grep -q running"
        [[ $? == 1 ]]
        $skip_step_if_already_done ; set -ex
        ssh root@${IP_ADDR} "systemctl disable ${service}"
        ssh root@${IP_ADDR} "systemctl stop ${service}"
    ) ; prev_cmd_failed
}

function ssh () {
    local key="${NODE_DIR}/sshkey"
    [[ -f ${key} ]] &&
        $(type -P ssh) -i "${key}" -o 'StrictHostKeyChecking=no' -o 'LogLevel=quiet' -o 'UserKnownHostsFile /dev/null' "${@}"
}

function destroy_bridge() {
  local name="$1"

  (
    $starting_step "Destroy bridge ${name}"
    brctl show | grep -q "${name}"
    [ "$?" != "0" ]
    $skip_step_if_already_done ; set -xe
    sudo ip link set "${1}" down
    sudo brctl delbr "${1}"
  ) ; prev_cmd_failed
}
