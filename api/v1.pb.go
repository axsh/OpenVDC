// Code generated by protoc-gen-go. DO NOT EDIT.
// source: v1.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	v1.proto

It has these top-level messages:
	ConsoleIn
	ConsoleOut
	RunReply
	StopRequest
	StopReply
	DestroyRequest
	DestroyReply
	CopyRequest
	CopyReply
	ForceStateRequest
	ForceStateReply
	ConsoleRequest
	ConsoleReply
	CreateRequest
	CreateReply
	StartRequest
	StartReply
	RebootRequest
	RebootReply
	InstanceIDRequest
	InstanceReply
	InstanceListRequest
	InstanceListReply
	InstanceLogRequest
	InstanceLogReply
	InstanceEventRequest
	InstanceEventReply
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import model "github.com/axsh/openvdc/model"
import model1 "github.com/axsh/openvdc/model"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ConsoleOut_Channel int32

const (
	ConsoleOut_stdout ConsoleOut_Channel = 0
	ConsoleOut_stderr ConsoleOut_Channel = 1
)

var ConsoleOut_Channel_name = map[int32]string{
	0: "stdout",
	1: "stderr",
}
var ConsoleOut_Channel_value = map[string]int32{
	"stdout": 0,
	"stderr": 1,
}

func (x ConsoleOut_Channel) String() string {
	return proto.EnumName(ConsoleOut_Channel_name, int32(x))
}
func (ConsoleOut_Channel) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type InstanceEventReply_EventType int32

const (
	InstanceEventReply_EventNone  InstanceEventReply_EventType = 0
	InstanceEventReply_EventState InstanceEventReply_EventType = 1
)

var InstanceEventReply_EventType_name = map[int32]string{
	0: "EventNone",
	1: "EventState",
}
var InstanceEventReply_EventType_value = map[string]int32{
	"EventNone":  0,
	"EventState": 1,
}

func (x InstanceEventReply_EventType) String() string {
	return proto.EnumName(InstanceEventReply_EventType_name, int32(x))
}
func (InstanceEventReply_EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{26, 0}
}

type ConsoleIn struct {
	Buf        string `protobuf:"bytes,1,opt,name=buf" json:"buf,omitempty"`
	InstanceId string `protobuf:"bytes,2,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *ConsoleIn) Reset()                    { *m = ConsoleIn{} }
func (m *ConsoleIn) String() string            { return proto.CompactTextString(m) }
func (*ConsoleIn) ProtoMessage()               {}
func (*ConsoleIn) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ConsoleIn) GetBuf() string {
	if m != nil {
		return m.Buf
	}
	return ""
}

func (m *ConsoleIn) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type ConsoleOut struct {
	Ch  ConsoleOut_Channel `protobuf:"varint,1,opt,name=ch,enum=api.ConsoleOut_Channel" json:"ch,omitempty"`
	Buf string             `protobuf:"bytes,2,opt,name=buf" json:"buf,omitempty"`
}

func (m *ConsoleOut) Reset()                    { *m = ConsoleOut{} }
func (m *ConsoleOut) String() string            { return proto.CompactTextString(m) }
func (*ConsoleOut) ProtoMessage()               {}
func (*ConsoleOut) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ConsoleOut) GetCh() ConsoleOut_Channel {
	if m != nil {
		return m.Ch
	}
	return ConsoleOut_stdout
}

func (m *ConsoleOut) GetBuf() string {
	if m != nil {
		return m.Buf
	}
	return ""
}

type RunReply struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *RunReply) Reset()                    { *m = RunReply{} }
func (m *RunReply) String() string            { return proto.CompactTextString(m) }
func (*RunReply) ProtoMessage()               {}
func (*RunReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RunReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type StopRequest struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *StopRequest) Reset()                    { *m = StopRequest{} }
func (m *StopRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRequest) ProtoMessage()               {}
func (*StopRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StopRequest) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type StopReply struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *StopReply) Reset()                    { *m = StopReply{} }
func (m *StopReply) String() string            { return proto.CompactTextString(m) }
func (*StopReply) ProtoMessage()               {}
func (*StopReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *StopReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type DestroyRequest struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *DestroyRequest) Reset()                    { *m = DestroyRequest{} }
func (m *DestroyRequest) String() string            { return proto.CompactTextString(m) }
func (*DestroyRequest) ProtoMessage()               {}
func (*DestroyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DestroyRequest) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type DestroyReply struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *DestroyReply) Reset()                    { *m = DestroyReply{} }
func (m *DestroyReply) String() string            { return proto.CompactTextString(m) }
func (*DestroyReply) ProtoMessage()               {}
func (*DestroyReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DestroyReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type CopyRequest struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *CopyRequest) Reset()                    { *m = CopyRequest{} }
func (m *CopyRequest) String() string            { return proto.CompactTextString(m) }
func (*CopyRequest) ProtoMessage()               {}
func (*CopyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CopyRequest) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type CopyReply struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
	Address    string `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
}

func (m *CopyReply) Reset()                    { *m = CopyReply{} }
func (m *CopyReply) String() string            { return proto.CompactTextString(m) }
func (*CopyReply) ProtoMessage()               {}
func (*CopyReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CopyReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

func (m *CopyReply) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ForceStateRequest struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *ForceStateRequest) Reset()                    { *m = ForceStateRequest{} }
func (m *ForceStateRequest) String() string            { return proto.CompactTextString(m) }
func (*ForceStateRequest) ProtoMessage()               {}
func (*ForceStateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ForceStateRequest) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type ForceStateReply struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *ForceStateReply) Reset()                    { *m = ForceStateReply{} }
func (m *ForceStateReply) String() string            { return proto.CompactTextString(m) }
func (*ForceStateReply) ProtoMessage()               {}
func (*ForceStateReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ForceStateReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type ConsoleRequest struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *ConsoleRequest) Reset()                    { *m = ConsoleRequest{} }
func (m *ConsoleRequest) String() string            { return proto.CompactTextString(m) }
func (*ConsoleRequest) ProtoMessage()               {}
func (*ConsoleRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ConsoleRequest) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type ConsoleReply struct {
	InstanceId string                   `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
	Type       model1.Console_Transport `protobuf:"varint,2,opt,name=type,enum=model.Console_Transport" json:"type,omitempty"`
	Address    string                   `protobuf:"bytes,3,opt,name=address" json:"address,omitempty"`
}

func (m *ConsoleReply) Reset()                    { *m = ConsoleReply{} }
func (m *ConsoleReply) String() string            { return proto.CompactTextString(m) }
func (*ConsoleReply) ProtoMessage()               {}
func (*ConsoleReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ConsoleReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

func (m *ConsoleReply) GetType() model1.Console_Transport {
	if m != nil {
		return m.Type
	}
	return model1.Console_SSH
}

func (m *ConsoleReply) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type CreateRequest struct {
	// string resource_id = 1; // Obsolete
	Template     *model.Template `protobuf:"bytes,2,opt,name=template" json:"template,omitempty"`
	AutoRecovery bool            `protobuf:"varint,3,opt,name=auto_recovery,json=autoRecovery" json:"auto_recovery,omitempty"`
}

func (m *CreateRequest) Reset()                    { *m = CreateRequest{} }
func (m *CreateRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRequest) ProtoMessage()               {}
func (*CreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *CreateRequest) GetTemplate() *model.Template {
	if m != nil {
		return m.Template
	}
	return nil
}

func (m *CreateRequest) GetAutoRecovery() bool {
	if m != nil {
		return m.AutoRecovery
	}
	return false
}

type CreateReply struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *CreateReply) Reset()                    { *m = CreateReply{} }
func (m *CreateReply) String() string            { return proto.CompactTextString(m) }
func (*CreateReply) ProtoMessage()               {}
func (*CreateReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *CreateReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type StartRequest struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *StartRequest) Reset()                    { *m = StartRequest{} }
func (m *StartRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()               {}
func (*StartRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *StartRequest) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type StartReply struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *StartReply) Reset()                    { *m = StartReply{} }
func (m *StartReply) String() string            { return proto.CompactTextString(m) }
func (*StartReply) ProtoMessage()               {}
func (*StartReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *StartReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type RebootRequest struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *RebootRequest) Reset()                    { *m = RebootRequest{} }
func (m *RebootRequest) String() string            { return proto.CompactTextString(m) }
func (*RebootRequest) ProtoMessage()               {}
func (*RebootRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *RebootRequest) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type RebootReply struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id" json:"instance_id,omitempty"`
}

func (m *RebootReply) Reset()                    { *m = RebootReply{} }
func (m *RebootReply) String() string            { return proto.CompactTextString(m) }
func (*RebootReply) ProtoMessage()               {}
func (*RebootReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *RebootReply) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

type InstanceIDRequest struct {
	// Types that are valid to be assigned to Key:
	//	*InstanceIDRequest_ID
	//	*InstanceIDRequest_Name
	Key isInstanceIDRequest_Key `protobuf_oneof:"Key"`
}

func (m *InstanceIDRequest) Reset()                    { *m = InstanceIDRequest{} }
func (m *InstanceIDRequest) String() string            { return proto.CompactTextString(m) }
func (*InstanceIDRequest) ProtoMessage()               {}
func (*InstanceIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type isInstanceIDRequest_Key interface {
	isInstanceIDRequest_Key()
}

type InstanceIDRequest_ID struct {
	ID string `protobuf:"bytes,1,opt,name=ID,oneof"`
}
type InstanceIDRequest_Name struct {
	Name string `protobuf:"bytes,2,opt,name=Name,oneof"`
}

func (*InstanceIDRequest_ID) isInstanceIDRequest_Key()   {}
func (*InstanceIDRequest_Name) isInstanceIDRequest_Key() {}

func (m *InstanceIDRequest) GetKey() isInstanceIDRequest_Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *InstanceIDRequest) GetID() string {
	if x, ok := m.GetKey().(*InstanceIDRequest_ID); ok {
		return x.ID
	}
	return ""
}

func (m *InstanceIDRequest) GetName() string {
	if x, ok := m.GetKey().(*InstanceIDRequest_Name); ok {
		return x.Name
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstanceIDRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstanceIDRequest_OneofMarshaler, _InstanceIDRequest_OneofUnmarshaler, _InstanceIDRequest_OneofSizer, []interface{}{
		(*InstanceIDRequest_ID)(nil),
		(*InstanceIDRequest_Name)(nil),
	}
}

func _InstanceIDRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstanceIDRequest)
	// Key
	switch x := m.Key.(type) {
	case *InstanceIDRequest_ID:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.ID)
	case *InstanceIDRequest_Name:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Name)
	case nil:
	default:
		return fmt.Errorf("InstanceIDRequest.Key has unexpected type %T", x)
	}
	return nil
}

func _InstanceIDRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstanceIDRequest)
	switch tag {
	case 1: // Key.ID
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Key = &InstanceIDRequest_ID{x}
		return true, err
	case 2: // Key.Name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Key = &InstanceIDRequest_Name{x}
		return true, err
	default:
		return false, nil
	}
}

func _InstanceIDRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstanceIDRequest)
	// Key
	switch x := m.Key.(type) {
	case *InstanceIDRequest_ID:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ID)))
		n += len(x.ID)
	case *InstanceIDRequest_Name:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type InstanceReply struct {
	ID       string          `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Instance *model.Instance `protobuf:"bytes,2,opt,name=instance" json:"instance,omitempty"`
}

func (m *InstanceReply) Reset()                    { *m = InstanceReply{} }
func (m *InstanceReply) String() string            { return proto.CompactTextString(m) }
func (*InstanceReply) ProtoMessage()               {}
func (*InstanceReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *InstanceReply) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *InstanceReply) GetInstance() *model.Instance {
	if m != nil {
		return m.Instance
	}
	return nil
}

type InstanceListRequest struct {
	Page   *InstanceListRequest_PageRequest `protobuf:"bytes,1,opt,name=page" json:"page,omitempty"`
	Filter *InstanceListRequest_Filter      `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
}

func (m *InstanceListRequest) Reset()                    { *m = InstanceListRequest{} }
func (m *InstanceListRequest) String() string            { return proto.CompactTextString(m) }
func (*InstanceListRequest) ProtoMessage()               {}
func (*InstanceListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *InstanceListRequest) GetPage() *InstanceListRequest_PageRequest {
	if m != nil {
		return m.Page
	}
	return nil
}

func (m *InstanceListRequest) GetFilter() *InstanceListRequest_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

type InstanceListRequest_PageRequest struct {
	Offset int32 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Limit  int32 `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`
}

func (m *InstanceListRequest_PageRequest) Reset()         { *m = InstanceListRequest_PageRequest{} }
func (m *InstanceListRequest_PageRequest) String() string { return proto.CompactTextString(m) }
func (*InstanceListRequest_PageRequest) ProtoMessage()    {}
func (*InstanceListRequest_PageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{21, 0}
}

func (m *InstanceListRequest_PageRequest) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *InstanceListRequest_PageRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type InstanceListRequest_Filter struct {
	State model.InstanceState_State `protobuf:"varint,1,opt,name=state,enum=model.InstanceState_State" json:"state,omitempty"`
}

func (m *InstanceListRequest_Filter) Reset()                    { *m = InstanceListRequest_Filter{} }
func (m *InstanceListRequest_Filter) String() string            { return proto.CompactTextString(m) }
func (*InstanceListRequest_Filter) ProtoMessage()               {}
func (*InstanceListRequest_Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 1} }

func (m *InstanceListRequest_Filter) GetState() model.InstanceState_State {
	if m != nil {
		return m.State
	}
	return model.InstanceState_REGISTERED
}

type InstanceListReply struct {
	Page  *InstanceListReply_PageReply          `protobuf:"bytes,1,opt,name=page" json:"page,omitempty"`
	Items []*InstanceListReply_InstanceListItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
}

func (m *InstanceListReply) Reset()                    { *m = InstanceListReply{} }
func (m *InstanceListReply) String() string            { return proto.CompactTextString(m) }
func (*InstanceListReply) ProtoMessage()               {}
func (*InstanceListReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *InstanceListReply) GetPage() *InstanceListReply_PageReply {
	if m != nil {
		return m.Page
	}
	return nil
}

func (m *InstanceListReply) GetItems() []*InstanceListReply_InstanceListItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type InstanceListReply_PageReply struct {
	Total   int32 `protobuf:"varint,1,opt,name=total" json:"total,omitempty"`
	Current int32 `protobuf:"varint,2,opt,name=current" json:"current,omitempty"`
	Limit   int32 `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
}

func (m *InstanceListReply_PageReply) Reset()                    { *m = InstanceListReply_PageReply{} }
func (m *InstanceListReply_PageReply) String() string            { return proto.CompactTextString(m) }
func (*InstanceListReply_PageReply) ProtoMessage()               {}
func (*InstanceListReply_PageReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 0} }

func (m *InstanceListReply_PageReply) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *InstanceListReply_PageReply) GetCurrent() int32 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *InstanceListReply_PageReply) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type InstanceListReply_InstanceListItem struct {
	Id    string                    `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	State model.InstanceState_State `protobuf:"varint,2,opt,name=state,enum=model.InstanceState_State" json:"state,omitempty"`
}

func (m *InstanceListReply_InstanceListItem) Reset()         { *m = InstanceListReply_InstanceListItem{} }
func (m *InstanceListReply_InstanceListItem) String() string { return proto.CompactTextString(m) }
func (*InstanceListReply_InstanceListItem) ProtoMessage()    {}
func (*InstanceListReply_InstanceListItem) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{22, 1}
}

func (m *InstanceListReply_InstanceListItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InstanceListReply_InstanceListItem) GetState() model.InstanceState_State {
	if m != nil {
		return m.State
	}
	return model.InstanceState_REGISTERED
}

type InstanceLogRequest struct {
	Target *InstanceIDRequest `protobuf:"bytes,1,opt,name=Target" json:"Target,omitempty"`
}

func (m *InstanceLogRequest) Reset()                    { *m = InstanceLogRequest{} }
func (m *InstanceLogRequest) String() string            { return proto.CompactTextString(m) }
func (*InstanceLogRequest) ProtoMessage()               {}
func (*InstanceLogRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *InstanceLogRequest) GetTarget() *InstanceIDRequest {
	if m != nil {
		return m.Target
	}
	return nil
}

type InstanceLogReply struct {
	Line []string `protobuf:"bytes,1,rep,name=Line" json:"Line,omitempty"`
}

func (m *InstanceLogReply) Reset()                    { *m = InstanceLogReply{} }
func (m *InstanceLogReply) String() string            { return proto.CompactTextString(m) }
func (*InstanceLogReply) ProtoMessage()               {}
func (*InstanceLogReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *InstanceLogReply) GetLine() []string {
	if m != nil {
		return m.Line
	}
	return nil
}

type InstanceEventRequest struct {
	Target *InstanceIDRequest `protobuf:"bytes,1,opt,name=Target" json:"Target,omitempty"`
}

func (m *InstanceEventRequest) Reset()                    { *m = InstanceEventRequest{} }
func (m *InstanceEventRequest) String() string            { return proto.CompactTextString(m) }
func (*InstanceEventRequest) ProtoMessage()               {}
func (*InstanceEventRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *InstanceEventRequest) GetTarget() *InstanceIDRequest {
	if m != nil {
		return m.Target
	}
	return nil
}

type InstanceEventReply struct {
	EventType InstanceEventReply_EventType `protobuf:"varint,1,opt,name=event_type,enum=api.InstanceEventReply_EventType" json:"event_type,omitempty"`
	EventAt   *google_protobuf.Timestamp   `protobuf:"bytes,2,opt,name=event_at" json:"event_at,omitempty"`
	// Types that are valid to be assigned to Body:
	//	*InstanceEventReply_State
	Body isInstanceEventReply_Body `protobuf_oneof:"Body"`
}

func (m *InstanceEventReply) Reset()                    { *m = InstanceEventReply{} }
func (m *InstanceEventReply) String() string            { return proto.CompactTextString(m) }
func (*InstanceEventReply) ProtoMessage()               {}
func (*InstanceEventReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

type isInstanceEventReply_Body interface {
	isInstanceEventReply_Body()
}

type InstanceEventReply_State struct {
	State *model.InstanceState `protobuf:"bytes,3,opt,name=state,oneof"`
}

func (*InstanceEventReply_State) isInstanceEventReply_Body() {}

func (m *InstanceEventReply) GetBody() isInstanceEventReply_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *InstanceEventReply) GetEventType() InstanceEventReply_EventType {
	if m != nil {
		return m.EventType
	}
	return InstanceEventReply_EventNone
}

func (m *InstanceEventReply) GetEventAt() *google_protobuf.Timestamp {
	if m != nil {
		return m.EventAt
	}
	return nil
}

func (m *InstanceEventReply) GetState() *model.InstanceState {
	if x, ok := m.GetBody().(*InstanceEventReply_State); ok {
		return x.State
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstanceEventReply) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstanceEventReply_OneofMarshaler, _InstanceEventReply_OneofUnmarshaler, _InstanceEventReply_OneofSizer, []interface{}{
		(*InstanceEventReply_State)(nil),
	}
}

func _InstanceEventReply_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstanceEventReply)
	// Body
	switch x := m.Body.(type) {
	case *InstanceEventReply_State:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.State); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstanceEventReply.Body has unexpected type %T", x)
	}
	return nil
}

func _InstanceEventReply_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstanceEventReply)
	switch tag {
	case 3: // Body.state
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(model.InstanceState)
		err := b.DecodeMessage(msg)
		m.Body = &InstanceEventReply_State{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstanceEventReply_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstanceEventReply)
	// Body
	switch x := m.Body.(type) {
	case *InstanceEventReply_State:
		s := proto.Size(x.State)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ConsoleIn)(nil), "api.ConsoleIn")
	proto.RegisterType((*ConsoleOut)(nil), "api.ConsoleOut")
	proto.RegisterType((*RunReply)(nil), "api.RunReply")
	proto.RegisterType((*StopRequest)(nil), "api.StopRequest")
	proto.RegisterType((*StopReply)(nil), "api.StopReply")
	proto.RegisterType((*DestroyRequest)(nil), "api.DestroyRequest")
	proto.RegisterType((*DestroyReply)(nil), "api.DestroyReply")
	proto.RegisterType((*CopyRequest)(nil), "api.CopyRequest")
	proto.RegisterType((*CopyReply)(nil), "api.CopyReply")
	proto.RegisterType((*ForceStateRequest)(nil), "api.ForceStateRequest")
	proto.RegisterType((*ForceStateReply)(nil), "api.ForceStateReply")
	proto.RegisterType((*ConsoleRequest)(nil), "api.ConsoleRequest")
	proto.RegisterType((*ConsoleReply)(nil), "api.ConsoleReply")
	proto.RegisterType((*CreateRequest)(nil), "api.CreateRequest")
	proto.RegisterType((*CreateReply)(nil), "api.CreateReply")
	proto.RegisterType((*StartRequest)(nil), "api.StartRequest")
	proto.RegisterType((*StartReply)(nil), "api.StartReply")
	proto.RegisterType((*RebootRequest)(nil), "api.RebootRequest")
	proto.RegisterType((*RebootReply)(nil), "api.RebootReply")
	proto.RegisterType((*InstanceIDRequest)(nil), "api.InstanceIDRequest")
	proto.RegisterType((*InstanceReply)(nil), "api.InstanceReply")
	proto.RegisterType((*InstanceListRequest)(nil), "api.InstanceListRequest")
	proto.RegisterType((*InstanceListRequest_PageRequest)(nil), "api.InstanceListRequest.PageRequest")
	proto.RegisterType((*InstanceListRequest_Filter)(nil), "api.InstanceListRequest.Filter")
	proto.RegisterType((*InstanceListReply)(nil), "api.InstanceListReply")
	proto.RegisterType((*InstanceListReply_PageReply)(nil), "api.InstanceListReply.PageReply")
	proto.RegisterType((*InstanceListReply_InstanceListItem)(nil), "api.InstanceListReply.InstanceListItem")
	proto.RegisterType((*InstanceLogRequest)(nil), "api.InstanceLogRequest")
	proto.RegisterType((*InstanceLogReply)(nil), "api.InstanceLogReply")
	proto.RegisterType((*InstanceEventRequest)(nil), "api.InstanceEventRequest")
	proto.RegisterType((*InstanceEventReply)(nil), "api.InstanceEventReply")
	proto.RegisterEnum("api.ConsoleOut_Channel", ConsoleOut_Channel_name, ConsoleOut_Channel_value)
	proto.RegisterEnum("api.InstanceEventReply_EventType", InstanceEventReply_EventType_name, InstanceEventReply_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for InstanceConsole service

type InstanceConsoleClient interface {
	Attach(ctx context.Context, opts ...grpc.CallOption) (InstanceConsole_AttachClient, error)
}

type instanceConsoleClient struct {
	cc *grpc.ClientConn
}

func NewInstanceConsoleClient(cc *grpc.ClientConn) InstanceConsoleClient {
	return &instanceConsoleClient{cc}
}

func (c *instanceConsoleClient) Attach(ctx context.Context, opts ...grpc.CallOption) (InstanceConsole_AttachClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InstanceConsole_serviceDesc.Streams[0], c.cc, "/api.InstanceConsole/Attach", opts...)
	if err != nil {
		return nil, err
	}
	x := &instanceConsoleAttachClient{stream}
	return x, nil
}

type InstanceConsole_AttachClient interface {
	Send(*ConsoleIn) error
	Recv() (*ConsoleOut, error)
	grpc.ClientStream
}

type instanceConsoleAttachClient struct {
	grpc.ClientStream
}

func (x *instanceConsoleAttachClient) Send(m *ConsoleIn) error {
	return x.ClientStream.SendMsg(m)
}

func (x *instanceConsoleAttachClient) Recv() (*ConsoleOut, error) {
	m := new(ConsoleOut)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for InstanceConsole service

type InstanceConsoleServer interface {
	Attach(InstanceConsole_AttachServer) error
}

func RegisterInstanceConsoleServer(s *grpc.Server, srv InstanceConsoleServer) {
	s.RegisterService(&_InstanceConsole_serviceDesc, srv)
}

func _InstanceConsole_Attach_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InstanceConsoleServer).Attach(&instanceConsoleAttachServer{stream})
}

type InstanceConsole_AttachServer interface {
	Send(*ConsoleOut) error
	Recv() (*ConsoleIn, error)
	grpc.ServerStream
}

type instanceConsoleAttachServer struct {
	grpc.ServerStream
}

func (x *instanceConsoleAttachServer) Send(m *ConsoleOut) error {
	return x.ServerStream.SendMsg(m)
}

func (x *instanceConsoleAttachServer) Recv() (*ConsoleIn, error) {
	m := new(ConsoleIn)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _InstanceConsole_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.InstanceConsole",
	HandlerType: (*InstanceConsoleServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Attach",
			Handler:       _InstanceConsole_Attach_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "v1.proto",
}

// Client API for Instance service

type InstanceClient interface {
	Copy(ctx context.Context, in *CopyRequest, opts ...grpc.CallOption) (*CopyReply, error)
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateReply, error)
	ForceState(ctx context.Context, in *ForceStateRequest, opts ...grpc.CallOption) (*ForceStateReply, error)
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error)
	Run(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*RunReply, error)
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error)
	Destroy(ctx context.Context, in *DestroyRequest, opts ...grpc.CallOption) (*DestroyReply, error)
	Reboot(ctx context.Context, in *RebootRequest, opts ...grpc.CallOption) (*RebootReply, error)
	Console(ctx context.Context, in *ConsoleRequest, opts ...grpc.CallOption) (*ConsoleReply, error)
	Show(ctx context.Context, in *InstanceIDRequest, opts ...grpc.CallOption) (*InstanceReply, error)
	List(ctx context.Context, in *InstanceListRequest, opts ...grpc.CallOption) (*InstanceListReply, error)
	Log(ctx context.Context, in *InstanceLogRequest, opts ...grpc.CallOption) (Instance_LogClient, error)
	Event(ctx context.Context, in *InstanceEventRequest, opts ...grpc.CallOption) (Instance_EventClient, error)
}

type instanceClient struct {
	cc *grpc.ClientConn
}

func NewInstanceClient(cc *grpc.ClientConn) InstanceClient {
	return &instanceClient{cc}
}

func (c *instanceClient) Copy(ctx context.Context, in *CopyRequest, opts ...grpc.CallOption) (*CopyReply, error) {
	out := new(CopyReply)
	err := grpc.Invoke(ctx, "/api.Instance/Copy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateReply, error) {
	out := new(CreateReply)
	err := grpc.Invoke(ctx, "/api.Instance/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) ForceState(ctx context.Context, in *ForceStateRequest, opts ...grpc.CallOption) (*ForceStateReply, error) {
	out := new(ForceStateReply)
	err := grpc.Invoke(ctx, "/api.Instance/ForceState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error) {
	out := new(StartReply)
	err := grpc.Invoke(ctx, "/api.Instance/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Run(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*RunReply, error) {
	out := new(RunReply)
	err := grpc.Invoke(ctx, "/api.Instance/Run", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error) {
	out := new(StopReply)
	err := grpc.Invoke(ctx, "/api.Instance/Stop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Destroy(ctx context.Context, in *DestroyRequest, opts ...grpc.CallOption) (*DestroyReply, error) {
	out := new(DestroyReply)
	err := grpc.Invoke(ctx, "/api.Instance/Destroy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Reboot(ctx context.Context, in *RebootRequest, opts ...grpc.CallOption) (*RebootReply, error) {
	out := new(RebootReply)
	err := grpc.Invoke(ctx, "/api.Instance/Reboot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Console(ctx context.Context, in *ConsoleRequest, opts ...grpc.CallOption) (*ConsoleReply, error) {
	out := new(ConsoleReply)
	err := grpc.Invoke(ctx, "/api.Instance/Console", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Show(ctx context.Context, in *InstanceIDRequest, opts ...grpc.CallOption) (*InstanceReply, error) {
	out := new(InstanceReply)
	err := grpc.Invoke(ctx, "/api.Instance/Show", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) List(ctx context.Context, in *InstanceListRequest, opts ...grpc.CallOption) (*InstanceListReply, error) {
	out := new(InstanceListReply)
	err := grpc.Invoke(ctx, "/api.Instance/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceClient) Log(ctx context.Context, in *InstanceLogRequest, opts ...grpc.CallOption) (Instance_LogClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Instance_serviceDesc.Streams[0], c.cc, "/api.Instance/Log", opts...)
	if err != nil {
		return nil, err
	}
	x := &instanceLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Instance_LogClient interface {
	Recv() (*InstanceLogReply, error)
	grpc.ClientStream
}

type instanceLogClient struct {
	grpc.ClientStream
}

func (x *instanceLogClient) Recv() (*InstanceLogReply, error) {
	m := new(InstanceLogReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *instanceClient) Event(ctx context.Context, in *InstanceEventRequest, opts ...grpc.CallOption) (Instance_EventClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Instance_serviceDesc.Streams[1], c.cc, "/api.Instance/Event", opts...)
	if err != nil {
		return nil, err
	}
	x := &instanceEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Instance_EventClient interface {
	Recv() (*InstanceEventReply, error)
	grpc.ClientStream
}

type instanceEventClient struct {
	grpc.ClientStream
}

func (x *instanceEventClient) Recv() (*InstanceEventReply, error) {
	m := new(InstanceEventReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Instance service

type InstanceServer interface {
	Copy(context.Context, *CopyRequest) (*CopyReply, error)
	Create(context.Context, *CreateRequest) (*CreateReply, error)
	ForceState(context.Context, *ForceStateRequest) (*ForceStateReply, error)
	Start(context.Context, *StartRequest) (*StartReply, error)
	Run(context.Context, *CreateRequest) (*RunReply, error)
	Stop(context.Context, *StopRequest) (*StopReply, error)
	Destroy(context.Context, *DestroyRequest) (*DestroyReply, error)
	Reboot(context.Context, *RebootRequest) (*RebootReply, error)
	Console(context.Context, *ConsoleRequest) (*ConsoleReply, error)
	Show(context.Context, *InstanceIDRequest) (*InstanceReply, error)
	List(context.Context, *InstanceListRequest) (*InstanceListReply, error)
	Log(*InstanceLogRequest, Instance_LogServer) error
	Event(*InstanceEventRequest, Instance_EventServer) error
}

func RegisterInstanceServer(s *grpc.Server, srv InstanceServer) {
	s.RegisterService(&_Instance_serviceDesc, srv)
}

func _Instance_Copy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Copy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Copy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Copy(ctx, req.(*CopyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_ForceState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).ForceState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/ForceState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).ForceState(ctx, req.(*ForceStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Run(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Destroy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Destroy(ctx, req.(*DestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Reboot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Reboot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Reboot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Reboot(ctx, req.(*RebootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Console_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Console(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Console",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Console(ctx, req.(*ConsoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/Show",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).Show(ctx, req.(*InstanceIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Instance/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServer).List(ctx, req.(*InstanceListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instance_Log_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceLogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InstanceServer).Log(m, &instanceLogServer{stream})
}

type Instance_LogServer interface {
	Send(*InstanceLogReply) error
	grpc.ServerStream
}

type instanceLogServer struct {
	grpc.ServerStream
}

func (x *instanceLogServer) Send(m *InstanceLogReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Instance_Event_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InstanceServer).Event(m, &instanceEventServer{stream})
}

type Instance_EventServer interface {
	Send(*InstanceEventReply) error
	grpc.ServerStream
}

type instanceEventServer struct {
	grpc.ServerStream
}

func (x *instanceEventServer) Send(m *InstanceEventReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Instance_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Instance",
	HandlerType: (*InstanceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Copy",
			Handler:    _Instance_Copy_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Instance_Create_Handler,
		},
		{
			MethodName: "ForceState",
			Handler:    _Instance_ForceState_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Instance_Start_Handler,
		},
		{
			MethodName: "Run",
			Handler:    _Instance_Run_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _Instance_Stop_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _Instance_Destroy_Handler,
		},
		{
			MethodName: "Reboot",
			Handler:    _Instance_Reboot_Handler,
		},
		{
			MethodName: "Console",
			Handler:    _Instance_Console_Handler,
		},
		{
			MethodName: "Show",
			Handler:    _Instance_Show_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Instance_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Log",
			Handler:       _Instance_Log_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Event",
			Handler:       _Instance_Event_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "v1.proto",
}

func init() { proto.RegisterFile("v1.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1146 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x5f, 0x73, 0xdb, 0x44,
	0x10, 0xb7, 0x25, 0xdb, 0xb1, 0xd7, 0xb1, 0xa3, 0x5c, 0x42, 0x12, 0xc4, 0x30, 0xa4, 0x82, 0xa1,
	0x99, 0xb4, 0x95, 0x5d, 0x87, 0xbf, 0x2d, 0x4c, 0xa7, 0x4e, 0x08, 0x75, 0xc9, 0x14, 0x50, 0xfc,
	0xc4, 0x4b, 0x46, 0xb1, 0x2f, 0xb2, 0x18, 0x59, 0x27, 0xa4, 0x53, 0xa8, 0x1f, 0xf9, 0x48, 0x3c,
	0xf1, 0xb9, 0xf8, 0x06, 0xcc, 0xfd, 0x93, 0xa5, 0xc4, 0x1e, 0xd4, 0xbe, 0x69, 0xf7, 0xf6, 0xb7,
	0xbf, 0xdb, 0xbd, 0xdb, 0xdb, 0x15, 0x34, 0x6f, 0x9f, 0xda, 0x51, 0x4c, 0x28, 0x41, 0xba, 0x1b,
	0xf9, 0x66, 0x7b, 0x4e, 0xa6, 0x38, 0x10, 0x1a, 0xb3, 0x33, 0x09, 0xd2, 0x84, 0xe2, 0x58, 0x8a,
	0xcf, 0x3d, 0x9f, 0xce, 0xd2, 0x6b, 0x7b, 0x42, 0xe6, 0x3d, 0x8f, 0x04, 0x6e, 0xe8, 0xf5, 0xf8,
	0xc2, 0x75, 0x7a, 0xd3, 0x8b, 0xe8, 0x22, 0xc2, 0x49, 0x8f, 0xfa, 0x73, 0x9c, 0x50, 0x77, 0x1e,
	0x2d, 0xbf, 0x04, 0xd8, 0x7a, 0x01, 0xad, 0x53, 0x12, 0x26, 0x24, 0xc0, 0xa3, 0x10, 0x19, 0xa0,
	0x5f, 0xa7, 0x37, 0x07, 0xd5, 0xc3, 0xea, 0x51, 0xcb, 0x61, 0x9f, 0xe8, 0x10, 0xda, 0x7e, 0x98,
	0x50, 0x37, 0x9c, 0xe0, 0x2b, 0x7f, 0x7a, 0xa0, 0xf1, 0x95, 0xbc, 0xca, 0xfa, 0x1d, 0x40, 0x3a,
	0xf8, 0x39, 0xa5, 0xe8, 0x21, 0x68, 0x93, 0x19, 0x77, 0xd0, 0x1d, 0xec, 0xdb, 0x6e, 0xe4, 0xdb,
	0xcb, 0x45, 0xfb, 0x74, 0xe6, 0x86, 0x21, 0x0e, 0x1c, 0x6d, 0x32, 0x53, 0x54, 0x5a, 0x46, 0x65,
	0x3d, 0x80, 0x0d, 0x69, 0x80, 0x00, 0x1a, 0x09, 0x9d, 0x92, 0x94, 0x1a, 0x15, 0xf9, 0x8d, 0xe3,
	0xd8, 0xa8, 0x5a, 0x03, 0x68, 0x3a, 0x69, 0xe8, 0xe0, 0x28, 0x58, 0xdc, 0xdd, 0x59, 0xf5, 0xde,
	0xce, 0x5e, 0xd7, 0x9a, 0x9a, 0xa1, 0x5b, 0x3d, 0x68, 0x5f, 0x52, 0x12, 0x39, 0xf8, 0x8f, 0x14,
	0x27, 0xf4, 0xff, 0x61, 0xd6, 0x13, 0x68, 0x09, 0x40, 0x29, 0x16, 0x6b, 0x00, 0xdd, 0x33, 0x9c,
	0xd0, 0x98, 0x2c, 0xca, 0x53, 0xf4, 0x61, 0x33, 0xc3, 0x94, 0x63, 0xe9, 0x41, 0xfb, 0x94, 0x44,
	0xef, 0x40, 0xf1, 0x23, 0x3b, 0xd7, 0xa8, 0xac, 0x7f, 0x74, 0x00, 0x1b, 0xee, 0x74, 0x1a, 0xe3,
	0x24, 0x91, 0x47, 0xa2, 0x44, 0xeb, 0x4b, 0xd8, 0x3e, 0x27, 0xf1, 0x04, 0x5f, 0x52, 0x97, 0xe2,
	0xf2, 0xfc, 0x27, 0xb0, 0x95, 0x87, 0x95, 0xce, 0xa5, 0xbc, 0x2e, 0xe5, 0x89, 0xde, 0xc2, 0x66,
	0x86, 0x29, 0x17, 0xeb, 0x63, 0xa8, 0xb1, 0xaa, 0xe0, 0x81, 0x76, 0x07, 0x07, 0xb6, 0x28, 0x2d,
	0xe9, 0xc4, 0x1e, 0xc7, 0x6e, 0x98, 0x44, 0x24, 0xa6, 0x0e, 0xb7, 0xca, 0x67, 0x46, 0x2f, 0x66,
	0xc6, 0x83, 0xce, 0x69, 0x8c, 0x73, 0x59, 0x79, 0x04, 0x4d, 0x8a, 0xe7, 0x51, 0xe0, 0x52, 0xe1,
	0xbc, 0x3d, 0xd8, 0x92, 0xce, 0xc7, 0x52, 0xed, 0x64, 0x06, 0xe8, 0x53, 0xe8, 0xb8, 0x29, 0x25,
	0x57, 0x31, 0x9e, 0x90, 0x5b, 0x1c, 0x2f, 0xb8, 0xf7, 0xa6, 0xb3, 0xc9, 0x94, 0x8e, 0xd4, 0xbd,
	0xae, 0x35, 0xab, 0x86, 0xc6, 0x0f, 0x5f, 0x12, 0x95, 0xcb, 0x63, 0x1f, 0x36, 0x2f, 0xa9, 0x1b,
	0xd3, 0xf2, 0x59, 0xb4, 0x01, 0x24, 0xa2, 0x1c, 0xc3, 0x53, 0xe8, 0x38, 0xf8, 0x9a, 0x90, 0x77,
	0xa0, 0xe8, 0x41, 0x5b, 0x41, 0xca, 0x71, 0x0c, 0x61, 0x7b, 0x24, 0xc5, 0xd1, 0x99, 0xe2, 0x31,
	0x40, 0x1b, 0x9d, 0x09, 0xeb, 0x57, 0x15, 0x47, 0x1b, 0x9d, 0xa1, 0x5d, 0xa8, 0xbd, 0x71, 0xe7,
	0x22, 0xe3, 0x4c, 0xc7, 0xa5, 0x61, 0x1d, 0xf4, 0x9f, 0xf0, 0xc2, 0xba, 0x80, 0x8e, 0xf2, 0x21,
	0x68, 0xbb, 0x4b, 0x3c, 0x47, 0x3f, 0x82, 0xa6, 0xe2, 0xbc, 0x73, 0x66, 0x19, 0x2e, 0x33, 0xb0,
	0xfe, 0xd2, 0x60, 0x47, 0xa9, 0x2f, 0xfc, 0x24, 0x0b, 0xfe, 0x1b, 0xa8, 0x45, 0xae, 0x87, 0xb9,
	0xdb, 0xf6, 0xe0, 0x33, 0xfe, 0xee, 0xad, 0xb0, 0xb3, 0x7f, 0x71, 0x3d, 0x75, 0x59, 0x1c, 0x8e,
	0x40, 0x5f, 0x43, 0xe3, 0xc6, 0x0f, 0x28, 0x8e, 0x25, 0xf9, 0x27, 0x6b, 0xb1, 0xe7, 0xdc, 0xcc,
	0x91, 0xe6, 0xe6, 0x73, 0x68, 0xe7, 0xbc, 0xa1, 0x3d, 0x68, 0x90, 0x9b, 0x9b, 0x04, 0x53, 0xbe,
	0x87, 0xba, 0x23, 0x25, 0xb4, 0x0b, 0xf5, 0xc0, 0x9f, 0xfb, 0x94, 0xbb, 0xaf, 0x3b, 0x42, 0x30,
	0x9f, 0x41, 0x43, 0xb8, 0x43, 0x7d, 0xa8, 0x27, 0xac, 0x42, 0xe5, 0x93, 0x6d, 0xde, 0x89, 0x9d,
	0x57, 0xaf, 0x2d, 0x6a, 0x58, 0x18, 0x5a, 0x7f, 0x6b, 0xcb, 0x63, 0x11, 0xfb, 0x63, 0x69, 0xfd,
	0xa2, 0x90, 0x81, 0xc3, 0x15, 0x51, 0x44, 0xc1, 0x42, 0xc6, 0x1f, 0x05, 0x0b, 0x19, 0xfd, 0xf7,
	0x50, 0xf7, 0x29, 0x9e, 0xb3, 0x37, 0x47, 0x3f, 0x6a, 0x0f, 0x1e, 0xae, 0x81, 0xe5, 0x35, 0x23,
	0x8a, 0xe7, 0x8e, 0x40, 0x99, 0xbf, 0x42, 0x2b, 0xf3, 0xc8, 0x22, 0xa5, 0x84, 0xba, 0x81, 0x4c,
	0x80, 0x10, 0x58, 0xf5, 0x4e, 0xd2, 0x38, 0xc6, 0xa1, 0xca, 0x80, 0x12, 0x97, 0x99, 0xd1, 0xf3,
	0x99, 0x19, 0x83, 0x71, 0x97, 0x8d, 0x5d, 0x99, 0xec, 0x82, 0x6a, 0xfe, 0x74, 0x99, 0x33, 0xad,
	0x6c, 0xce, 0xce, 0x00, 0x65, 0x5e, 0x89, 0xa7, 0xce, 0xcc, 0x86, 0xc6, 0xd8, 0x8d, 0x3d, 0x79,
	0x66, 0xed, 0xc1, 0x5e, 0x21, 0xfc, 0xec, 0xca, 0x3b, 0xd2, 0xca, 0xfa, 0x3c, 0xb7, 0x37, 0xe6,
	0x85, 0x45, 0x8d, 0xa0, 0x76, 0xe1, 0x87, 0x2c, 0xef, 0xfa, 0x51, 0xcb, 0xe1, 0xdf, 0xd6, 0x39,
	0xec, 0x2a, 0xbb, 0x1f, 0x6e, 0x71, 0x48, 0xdf, 0x97, 0xef, 0xdf, 0xea, 0x72, 0xdb, 0xd2, 0x11,
	0xa3, 0x7c, 0x09, 0x80, 0x99, 0x74, 0xc5, 0x1f, 0x51, 0x71, 0x6f, 0x1e, 0x14, 0x5c, 0x2d, 0x8d,
	0x6d, 0xfe, 0x39, 0x5e, 0x44, 0xd8, 0xc9, 0x81, 0xd0, 0x57, 0xd0, 0x14, 0x92, 0x4b, 0xe5, 0xbd,
	0x37, 0x6d, 0x8f, 0x10, 0x2f, 0xc0, 0xb6, 0x9a, 0x5c, 0xec, 0xb1, 0x1a, 0x54, 0x9c, 0xcc, 0x16,
	0x3d, 0x56, 0x99, 0xd7, 0x39, 0x68, 0x77, 0x55, 0xe6, 0x5f, 0x55, 0x54, 0xd6, 0x8f, 0xa1, 0x95,
	0xd1, 0xa3, 0x8e, 0x14, 0xde, 0x90, 0x10, 0x1b, 0x15, 0xd4, 0x05, 0xe0, 0x22, 0x87, 0x18, 0xd5,
	0x61, 0x03, 0x6a, 0x43, 0x32, 0x5d, 0x0c, 0x86, 0xb0, 0xa5, 0xbc, 0xc9, 0x86, 0x80, 0x7a, 0xd0,
	0x78, 0x49, 0xa9, 0x3b, 0x99, 0xa1, 0x6e, 0x7e, 0xa0, 0x19, 0x85, 0xe6, 0xd6, 0x9d, 0x01, 0xc7,
	0xaa, 0x1c, 0x55, 0xfb, 0xd5, 0xc1, 0x3f, 0x75, 0x68, 0x2a, 0x27, 0xe8, 0x18, 0x6a, 0xac, 0x0f,
	0x23, 0x43, 0xda, 0x66, 0x3d, 0xdc, 0xec, 0xe6, 0x34, 0x51, 0xb0, 0xb0, 0x2a, 0xa8, 0x0f, 0x0d,
	0xf1, 0xce, 0x23, 0x24, 0xd6, 0xf2, 0xdd, 0xc5, 0x34, 0x0a, 0x3a, 0x81, 0xf8, 0x0e, 0x60, 0xd9,
	0x65, 0x91, 0x38, 0xd0, 0x7b, 0xdd, 0xda, 0xdc, 0xbd, 0xa7, 0x17, 0xe8, 0x27, 0x50, 0xe7, 0x8f,
	0x3e, 0xda, 0xe6, 0x06, 0xf9, 0x96, 0x21, 0x63, 0x5b, 0xf6, 0x04, 0xab, 0x82, 0x8e, 0x41, 0x77,
	0xd2, 0x70, 0xe5, 0xde, 0x3a, 0x5c, 0xa7, 0x66, 0x33, 0x6e, 0x5b, 0x63, 0x43, 0x94, 0x0c, 0x3b,
	0x37, 0x80, 0xc9, 0xb0, 0xb3, 0x09, 0xcb, 0xaa, 0xa0, 0x13, 0xd8, 0x90, 0xd3, 0x10, 0xda, 0xe1,
	0x8b, 0xc5, 0x79, 0xca, 0xdc, 0x2e, 0x2a, 0xb3, 0x5c, 0x89, 0x6e, 0x22, 0xf7, 0x53, 0xe8, 0x46,
	0x32, 0x57, 0xb9, 0x76, 0x23, 0x68, 0xd4, 0x91, 0xee, 0xe4, 0x0f, 0xae, 0x48, 0x93, 0x9f, 0x25,
	0xac, 0x0a, 0x7b, 0xd7, 0x2e, 0x67, 0xe4, 0x4f, 0xb4, 0xa6, 0x56, 0x4c, 0x54, 0xd0, 0x2b, 0xd4,
	0x33, 0x56, 0x95, 0x09, 0x45, 0x07, 0xeb, 0x5e, 0x73, 0x73, 0x6f, 0xf5, 0x53, 0x67, 0x55, 0xd0,
	0xb7, 0xa0, 0x5f, 0x10, 0x0f, 0xed, 0x17, 0x0d, 0xb2, 0x57, 0xc3, 0xfc, 0xe0, 0xfe, 0x02, 0x07,
	0xf6, 0xab, 0xe8, 0x05, 0xd4, 0xf9, 0xa5, 0x46, 0x1f, 0xae, 0x2a, 0x47, 0x01, 0xdf, 0x5f, 0x53,
	0xa9, 0xcc, 0xc1, 0xf0, 0xe3, 0xdf, 0x3e, 0xca, 0xfd, 0x4b, 0xb8, 0x6f, 0x93, 0x59, 0x8f, 0x44,
	0x38, 0xbc, 0x9d, 0x4e, 0x7a, 0x6e, 0xe4, 0x5f, 0x37, 0x78, 0x71, 0x9e, 0xfc, 0x17, 0x00, 0x00,
	0xff, 0xff, 0xe0, 0x04, 0x68, 0xbc, 0x9c, 0x0c, 0x00, 0x00,
}
